<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cyrus&#39; blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-04-09T04:34:43.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Cyrus</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS KVO(键值观察) 总览</title>
    <link href="http://yoursite.com/2016/04/07/iOS-KVO-%E9%94%AE%E5%80%BC%E8%A7%82%E5%AF%9F-%E6%80%BB%E8%A7%88/"/>
    <id>http://yoursite.com/2016/04/07/iOS-KVO-键值观察-总览/</id>
    <published>2016-04-07T13:59:28.000Z</published>
    <updated>2016-04-09T04:34:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xrpns.com1.z0.glb.clouddn.com/heading-KVO.png" alt=""></p>
<p>本文主要内容来自于对官方文档 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177-BCICJDHA" target="_blank" rel="external">Key-Value Observing Programming Guide</a> 的翻译，以及一部分我自己的理解和解释，如果有说错的地方请及时联系我。</p>
<h2 id="At-a-Glance"><a href="#At-a-Glance" class="headerlink" title="At a Glance"></a>At a Glance</h2><p>KVO 也就是 键值观察 ，它提供了一种机制，使得当某个对象特定的属性发生改变时能够通知到别的对象。这经常用于 model 和 controller 之间的通信。KVO主要的优点是你不需要在每次属性改变时手动去发送通知。并且它支持为一个属性注册多个观察者。</p>
<h2 id="注册-KVO"><a href="#注册-KVO" class="headerlink" title="注册 KVO"></a>注册 KVO</h2><ul>
<li><strong>被观察对象</strong> 的属性必须是 <a href="file:///Users/hcy/Library/Developer/Shared/Documentation/DocSets/com.apple.adc.documentation.iOS.docset/Contents/Resources/Documents/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOCompliance.html#//apple_ref/doc/uid/20002178-BAJEAIEE" target="_blank" rel="external">KVO Compliant</a></li>
<li>必须用 <strong>被观察对象</strong> 的 <code>addObserver:forKeyPath:options:context:</code> 方法注册观察者</li>
<li><strong>观察者</strong> 必须实现 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法</li>
</ul>
<a id="more"></a>
<h3 id="注册成为观察者"><a href="#注册成为观察者" class="headerlink" title="注册成为观察者"></a>注册成为观察者</h3><hr>
<p>为了能够在属性改变时被通知到，一个 <strong>观察者对象</strong> 必须通过 <strong>被观察对象</strong> 的<code>addObserver:forKeyPath:options:context:</code> 方法注册成为观察者。</p>
<ul>
<li><code>observer</code> 参数也就是一个观察者对象</li>
<li><code>keyPath</code>  表示要观察的属性</li>
<li><p><code>options</code>  决定了提供给观察者change字典中的具体信息有哪些。（change字典是一个提供给观察者的参数，后面会提到）</p>
<ul>
<li><code>NSKeyValueObservingOptionOld</code> 表示在change字典中包含了改变前的值。  </li>
<li><code>NSKeyValueObservingOptionNew</code> 表示在change字典中包含新的值。</li>
<li><code>NSKeyValueObservingOptionInitial</code> 在注册观察者的方法return的时候就会发出一次通知。</li>
<li><code>NSKeyValueObservingOptionPrior</code> 会在值发生改变前发出一次通知，当然改变后的通知依旧还会发出，也就是每次change都会有两个通知。</li>
</ul>
</li>
<li><p><code>context</code> 这个参数可以是一个 C指针，也可以是一个 对象引用，它可以作为这个context的唯一标识，也可以提供一些数据给观察者。</p>
</li>
</ul>
<blockquote>
<p>注意：  <code>addObserver:forKeyPath:options:context:</code> 方法不会持有观察者对象，被观察对象，以及context的强引用。你要确保自己持有了他们的强引用。</p>
</blockquote>
<h3 id="属性变化时接收通知"><a href="#属性变化时接收通知" class="headerlink" title="属性变化时接收通知"></a>属性变化时接收通知</h3><hr>
<p>当一个被观察属性的值发生改变时，观察者会收到 <code>observeValueForKeyPath:ofObject:change:context:</code> 的消息。所有的观察者必须实现这个方法。这个方法中的参数和注册观察者方法的参数基本相同，只有一个 <code>change</code> 不同。 <code>change</code> 是一个字典，它里面包含了的信息由注册时的 <code>options</code> 决定。</p>
<p>官方提供了这些key给我们来取到 <code>change</code> 中的value： </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">NSKeyValueChangeKindKey</span>;</span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">NSKeyValueChangeNewKey</span>;</span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">NSKeyValueChangeOldKey</span>;</span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">NSKeyValueChangeIndexesKey</span>;</span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">NSKeyValueChangeNotificationIsPriorKey</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong><code>NSKeyValueChangeKindKey</code></strong> 这个key包含的value是一个 NSNumber 里面是一个 int，与之对应的是 <code>NSKeyValueChange</code> 的枚举</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">   <span class="built_in">NSKeyValueChangeSetting</span> = <span class="number">1</span>,</span><br><span class="line">   <span class="built_in">NSKeyValueChangeInsertion</span> = <span class="number">2</span>,</span><br><span class="line">   <span class="built_in">NSKeyValueChangeRemoval</span> = <span class="number">3</span>,</span><br><span class="line">   <span class="built_in">NSKeyValueChangeReplacement</span> = <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSUInteger</span> <span class="built_in">NSKeyValueChange</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>当 <code>change[NSKeyValueChangeKindKey]</code> 是 <code>NSKeyValueChangeSetting</code> 的时候，说明被观察属性的setter方法被调用了。<br>而下面三种，根据官方文档的意思是，当被观察属性是集合类型，且对它进行了 insert，remove，replace 操作的时候会返回这三种Key，但是我自己测试的时候没有测试出来😓不知道是不是我理解错了。</p>
<ul>
<li><p><strong><code>NSKeyValueChangeNewKey</code></strong>，<strong><code>NSKeyValueChangeOldKey</code></strong> 顾名思义，当你在注册的时候 <code>options</code> 参数中填了对应的 <code>NSKeyValueObservingOptionNew</code> 和 <code>NSKeyValueObservingOptionOld</code> ，并且 <code>NSKeyValueChangeKindKey</code> 的值是 <code>NSKeyValueChangeSetting</code> ，你就可以通过这两个key取到 旧值和新值。</p>
</li>
<li><p><strong><code>NSKeyValueChangeIndexesKey</code></strong>， 当 <code>NSKeyValueChangeKindKey</code> 的结果是 <code>NSKeyValueChangeInsertion</code>, <code>NSKeyValueChangeRemoval</code> 或 <code>NSKeyValueChangeReplacement</code> 的时候，这个key的value是一个NSIndexSet，包含了发生insert，remove，replace的对象的索引集合</p>
</li>
<li><p><strong><code>NSKeyValueChangeNotificationIsPriorKey</code></strong>，这个key包含了一个 NSNumber，里面是一个布尔值，如果在注册时 <code>options</code> 中有 <code>NSKeyValueObservingOptionPrior</code>，那么在前一个通知中的 <code>change</code> 中就会有这个key的value， 我们可以这样来判断是不是在改变前的通知<code>[change[NSKeyValueChangeNotificationIsPriorKey] boolValue] == YES;</code></p>
</li>
</ul>
<h3 id="移除一个观察者"><a href="#移除一个观察者" class="headerlink" title="移除一个观察者"></a>移除一个观察者</h3><hr>
<p>你可以通过 <code>removeObserver:forKeyPath:</code> 方法来移除一个观察。如果你的 <code>context</code> 是一个 对象，你必须在移除观察之前持有它的强引用。当移除了观察后，观察者对象再也不会受到这个 keyPath 的通知。</p>
<h2 id="KVO-Compliance"><a href="#KVO-Compliance" class="headerlink" title="KVO Compliance"></a>KVO Compliance</h2><p>有两种方式能够保证 change notification 能够被发出。</p>
<ul>
<li>自动通知，继承自NSObject，并且所有的属性符合<a href="file:///Users/hcy/Library/Developer/Shared/Documentation/DocSets/com.apple.adc.documentation.iOS.docset/Contents/Resources/Documents/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/Compliant.html#//apple_ref/doc/uid/20002172" target="_blank" rel="external">KVC规范</a>这样就不用写额外的代码去实现自动通知。</li>
<li>手动通知，让你的子类实现 <code>automaticallyNotifiesObserversForKey:</code> 方法，来决定是否需要自动通知，如果是手动通知需要额外的代码。</li>
</ul>
<h3 id="自动通知"><a href="#自动通知" class="headerlink" title="自动通知"></a>自动通知</h3><hr>
<p> NSObject 已经实现了自动通知，只要通过 setter 方法去赋值，或者通过 KVC 就可以通知到观察者。自动通知也支持集合代理对象，比如 mutableArrayValueForKey: 方法。</p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Call the accessor method.</span></span><br><span class="line">[account setName:<span class="string">@"Savings"</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Use setValue:forKey:.</span></span><br><span class="line">[account setValue:<span class="string">@"Savings"</span> forKey:<span class="string">@"name"</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Use a key path, where 'account' is a kvc-compliant property of 'document'.</span></span><br><span class="line">[document setValue:<span class="string">@"Savings"</span> forKeyPath:<span class="string">@"account.name"</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Use mutableArrayValueForKey: to retrieve a relationship proxy object.</span></span><br><span class="line">Transaction *newTransaction = &lt;<span class="meta">#Create a new transaction for the account#&gt;;</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *transactions = [account mutableArrayValueForKey:<span class="string">@"transactions"</span>];</span><br><span class="line">[transactions addObject:newTransaction];</span><br></pre></td></tr></table></figure>
<h3 id="手动通知"><a href="#手动通知" class="headerlink" title="手动通知"></a>手动通知</h3><hr>
<p> 手动通知提供了更自由的方式去决定什么时间，什么方式去通知观察者。这可以帮助你最少限度触发不必要的通知，或者一组改变值发出一个通知。想要使用手动通知必须实现<code>automaticallyNotifiesObserversForKey:</code> 方法。(或者<code>automaticallyNotifiesObserversOfS&lt;Key&gt;</code>)在一个类中同时使用自动和手动通知是可行的。对于想要手动通知的属性，可以根据它的keyPath返回NO，而其对于其他位置的keyPath，要返回父类的这个方法。</p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> + (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)theKey &#123;</span><br><span class="line">    	<span class="built_in">BOOL</span> automatic = <span class="literal">NO</span>;</span><br><span class="line">    	<span class="keyword">if</span> ([theKey isEqualToString:<span class="string">@"openingBalance"</span>]) &#123;</span><br><span class="line">    	    automatic = <span class="literal">NO</span>;</span><br><span class="line">   		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     	    automatic = [<span class="keyword">super</span> automaticallyNotifiesObserversForKey:theKey];</span><br><span class="line">   	 	&#125;</span><br><span class="line">   	 	<span class="keyword">return</span> automatic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 要实现手动通知，你需要在值改变前调用 <code>willChangeValueForKey:</code> 方法，在值改变后调用 <code>didChangeValueForKey:</code> 方法。你可以在发送通知前检查值是否改变，如果没有改变就不发送通知</p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)setOpeningBalance:(<span class="keyword">double</span>)theBalance &#123;</span><br><span class="line">    	<span class="keyword">if</span> (theBalance != _openingBalance) &#123;</span><br><span class="line">       	 [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"openingBalance"</span>];</span><br><span class="line">       	 _openingBalance = theBalance;</span><br><span class="line">       	 [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"openingBalance"</span>];</span><br><span class="line">   	 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 如果一个操作会导致多个属性改变，你需要嵌套通知，像下面这样：</p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)setOpeningBalance:(<span class="keyword">double</span>)theBalance &#123;</span><br><span class="line">    	[<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"openingBalance"</span>];</span><br><span class="line">    	[<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"itemChanged"</span>];</span><br><span class="line">   	 	_openingBalance = theBalance;</span><br><span class="line">    	_itemChanged = _itemChanged+<span class="number">1</span>;</span><br><span class="line">    	[<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"itemChanged"</span>];</span><br><span class="line">    	[<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"openingBalance"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在一个一对多的关系中，你必须注意不仅仅是这个key改变了，还有它改变的类型以及索引。</p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)removeTransactionsAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes &#123;</span><br><span class="line">    	[<span class="keyword">self</span> willChange:<span class="built_in">NSKeyValueChangeRemoval</span> valuesAtIndexes:indexes forKey:<span class="string">@"transactions"</span>];</span><br><span class="line"> </span><br><span class="line">	   	<span class="comment">// Remove the transaction objects at the specified indexes.</span></span><br><span class="line"> </span><br><span class="line">    	[<span class="keyword">self</span> didChange:<span class="built_in">NSKeyValueChangeRemoval</span> valuesAtIndexes:indexes forKey:<span class="string">@"transactions"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="键之间的依赖"><a href="#键之间的依赖" class="headerlink" title="键之间的依赖"></a>键之间的依赖</h2><p>在很多种情况下一个属性的值依赖于在其他对象中的属性。如果一个依赖属性的值改变了，这个属性也需要被通知到。</p>
<h3 id="To-one-Relationships"><a href="#To-one-Relationships" class="headerlink" title="To-one Relationships"></a>To-one Relationships</h3><hr>
<p>比如有一个教 <code>fullName</code> 的属性，依赖于 <code>firstName</code> 和 <code>lastName</code>，当 <code>firstName</code> 或者 <code>lastName</code> 改变时，这个 <code>fullName</code> 属性需要被通知到。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)fullName &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ %@"</span>,firstName, lastName];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以重写 <code>keyPathsForValuesAffectingValueForKey:</code> 方法。其中要先调父类的这个方法拿到一个set，再做接下来的操作。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSSet</span> *keyPaths = [<span class="keyword">super</span> keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"fullName"</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *affectingKeys = @[<span class="string">@"lastName"</span>, <span class="string">@"firstName"</span>];</span><br><span class="line">        keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以通过实现 <code>keyPathsForValuesAffecting&lt;Key&gt;</code> 方法来达到前面同样的效果，这里的<key>就是属性名，不过第一个字母要大写，用前面的例子来说就是这样：</key></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingFullName &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"lastName"</span>, <span class="string">@"firstName"</span>, <span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="To-many-Relationships"><a href="#To-many-Relationships" class="headerlink" title="To-many Relationships"></a>To-many Relationships</h3><hr>
<p><code>keyPathsForValuesAffectingValueForKey:</code>方法不能支持 to-many 的关系。举个例子，比如你有一个 Department 对象，和很多个 Employee 对象。而 Employee 有一个 salary 属性。你可能希望 Department 对象有一个 totalSalary 的属性，依赖于所有的 Employee 的 salary 。</p>
<p>你可以注册 Department 成为所有 Employee 的观察者。当 Employee 被添加或者被移除时，你必须要添加和移除观察者。然后在 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法中，根据改变做出反馈。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="keyword">if</span> (context == totalSalaryContext) &#123;</span><br><span class="line">        [<span class="keyword">self</span> updateTotalSalary];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// deal with other observations and/or invoke super...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">void</span>)updateTotalSalary &#123;</span><br><span class="line">    [<span class="keyword">self</span> setTotalSalary:[<span class="keyword">self</span> valueForKeyPath:<span class="string">@"employees.@sum.salary"</span>]];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">void</span>)setTotalSalary:(<span class="built_in">NSNumber</span> *)newTotalSalary &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (totalSalary != newTotalSalary) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"totalSalary"</span>];</span><br><span class="line">        _totalSalary = newTotalSalary;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"totalSalary"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (<span class="built_in">NSNumber</span> *)totalSalary &#123;</span><br><span class="line">    <span class="keyword">return</span> _totalSalary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="KVO的实现细节"><a href="#KVO的实现细节" class="headerlink" title="KVO的实现细节"></a>KVO的实现细节</h2><p>KVO 的实现用了一种叫 <strong><code>isa-swizzling</code></strong> 的技术。isa 指针就是指向类的指针，当一个对象的一个属性注册了观察者后，被观察对象的isa指针的就指向了一个系统为我们生成的中间类，而不是我们自己创建的类。在这个类中，系统为我们重写了被观察属性的setter方法。你可以通过 <code>object_getClass(id obj)</code> 方法获得对象真实的类,在 addObserver 前后分别打印，就可以看到isa指针被指向了一个中间类。似乎都是在原来的类名前面加上 <code>NSKVONotifying_</code></p>
<p>isa指针不总是指向真实的类，所以你不应该依赖于 isa 指针来判断这个对象的类型，而应该通过 <code>class</code> 方法来判断对象的类型。如果你还不知道什么是isa指针，可以看我之前写的博客 <a href="http://blog.cyrusdev.com/2016/03/10/Objective-C-runtime-%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">Objective-C runtime 的简单理解与使用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xrpns.com1.z0.glb.clouddn.com/heading-KVO.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文主要内容来自于对官方文档 &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177-BCICJDHA&quot;&gt;Key-Value Observing Programming Guide&lt;/a&gt; 的翻译，以及一部分我自己的理解和解释，如果有说错的地方请及时联系我。&lt;/p&gt;
&lt;h2 id=&quot;At-a-Glance&quot;&gt;&lt;a href=&quot;#At-a-Glance&quot; class=&quot;headerlink&quot; title=&quot;At a Glance&quot;&gt;&lt;/a&gt;At a Glance&lt;/h2&gt;&lt;p&gt;KVO 也就是 键值观察 ，它提供了一种机制，使得当某个对象特定的属性发生改变时能够通知到别的对象。这经常用于 model 和 controller 之间的通信。KVO主要的优点是你不需要在每次属性改变时手动去发送通知。并且它支持为一个属性注册多个观察者。&lt;/p&gt;
&lt;h2 id=&quot;注册-KVO&quot;&gt;&lt;a href=&quot;#注册-KVO&quot; class=&quot;headerlink&quot; title=&quot;注册 KVO&quot;&gt;&lt;/a&gt;注册 KVO&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;被观察对象&lt;/strong&gt; 的属性必须是 &lt;a href=&quot;file:///Users/hcy/Library/Developer/Shared/Documentation/DocSets/com.apple.adc.documentation.iOS.docset/Contents/Resources/Documents/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOCompliance.html#//apple_ref/doc/uid/20002178-BAJEAIEE&quot;&gt;KVO Compliant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;必须用 &lt;strong&gt;被观察对象&lt;/strong&gt; 的 &lt;code&gt;addObserver:forKeyPath:options:context:&lt;/code&gt; 方法注册观察者&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;观察者&lt;/strong&gt; 必须实现 &lt;code&gt;observeValueForKeyPath:ofObject:change:context:&lt;/code&gt; 方法&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="KVO" scheme="http://yoursite.com/tags/KVO/"/>
    
  </entry>
  
  <entry>
    <title>iOS 转场时 appear 与 disappear 的调用顺序探索</title>
    <link href="http://yoursite.com/2016/04/06/iOS-%E8%BD%AC%E5%9C%BA%E6%97%B6-appear-%E4%B8%8E-disappear-%E7%9A%84%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F%E6%8E%A2%E7%B4%A2/"/>
    <id>http://yoursite.com/2016/04/06/iOS-转场时-appear-与-disappear-的调用顺序探索/</id>
    <published>2016-04-06T13:41:52.000Z</published>
    <updated>2016-04-06T13:43:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xrpns.com1.z0.glb.clouddn.com/heading-Appear&Disappear.png"></p>
<p>最近几天看了好多人的面经，时不时就看到一个问题：</p>
<blockquote>
<p>在A页面跳转到B页面的过程中 A 的 viewDidDisappear 方法和 B 的 viewDidAppear 谁先调用？</p>
</blockquote>
<p>其实我以前一直理所当然的认为它们的顺序就是 <code>A-viewDidDisappear</code>  –&gt; <code>B-viewDidAppear</code>，至于为什么会这么想，就是感觉<img src="http://7xs81e.com1.z0.glb.clouddn.com/%E4%B8%80%E8%84%B8%E6%87%B5%E9%80%BC.png" ,="" width="40"></p>
<p>今天写了个Demo去测试了一下，发现完全不是自己想象的那样，每一种转场(Push,Present，TabBar切换)都是不一样的。</p>
<blockquote>
<p><a href="https://github.com/Hcy91425/Demo/tree/master/Appear%26Disappear-Sample" target="_blank" rel="external">Demo 地址 Appear&amp;Disappear-Sample</a></p>
</blockquote>
<a id="more"></a>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><hr>
<p>我自定义了两个类，继承自UIViewController，为了方便观察分别叫做<code>A_ViewController</code>,<code>B_ViewController</code>，然后重写了一系列 <code>appear</code> 和 <code>disappear</code> 方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"A  view will appear    %@"</span>,<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"A  view did  appear    %@"</span>,<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillDisappear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"A  view will disappear %@"</span>,<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidDisappear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidDisappear: animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"A  view did  disappear %@"</span>,<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后分别用 push， present， 以及 tabbar 的切换来测试，然后查看打印的结果。</p>
<h3 id="Push-amp-Pop"><a href="#Push-amp-Pop" class="headerlink" title="Push &amp; Pop"></a>Push &amp; Pop</h3><hr>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--------------------------PUSH-----------------------------</span><br><span class="line"></span><br><span class="line"> A  view will disappear &lt;A_ViewController: <span class="number">0x7fa11067a730</span>&gt;</span><br><span class="line"> B  view will appear    &lt;B_ViewController: <span class="number">0x7fa110516530</span>&gt;</span><br><span class="line"> A  view did  disappear &lt;A_ViewController: <span class="number">0x7fa11067a730</span>&gt;</span><br><span class="line"> B  view did  appear    &lt;B_ViewController: <span class="number">0x7fa110516530</span>&gt;</span><br><span class="line"></span><br><span class="line">--------------------------POP-----------------------------</span><br><span class="line"></span><br><span class="line"> B  view will disappear &lt;B_ViewController: <span class="number">0x7fa110516530</span>&gt;</span><br><span class="line"> A  view will appear    &lt;A_ViewController: <span class="number">0x7fa11067a730</span>&gt;</span><br><span class="line"> B  view did  disappear &lt;B_ViewController: <span class="number">0x7fa110516530</span>&gt;</span><br><span class="line"> A  view did  appear    &lt;A_ViewController: <span class="number">0x7fa11067a730</span>&gt;</span><br></pre></td></tr></table></figure>
<p>在这里的调用顺序是和我之前预想的一样的，也就是 </p>
<p><code>A-willDisappear</code> –&gt; <code>B-willAppear</code> –&gt; <code>A-didDisappear</code> –&gt; <code>B-didAppear</code></p>
<h3 id="Present-amp-Dismiss"><a href="#Present-amp-Dismiss" class="headerlink" title="Present &amp; Dismiss"></a>Present &amp; Dismiss</h3><hr>
<p>在模态的转场中就有一些不一样的事了。我们知道模态转场有好多种style，其中有两种我们需要特别注意的<code>UIModalPresentationCustom</code>,<code>UIModalPresentationOverFullScreen</code>。我们先看一下除了这两种style以外的转场，他们的调用顺序是怎样的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-----------------------NormalPresent------------------------</span><br><span class="line"></span><br><span class="line"> A  view will disappear &lt;A_ViewController: <span class="number">0x7fc2a14ac490</span>&gt;</span><br><span class="line"> B  view will appear    &lt;B_ViewController: <span class="number">0x7fc2a152a880</span>&gt;</span><br><span class="line"> B  view did  appear    &lt;B_ViewController: <span class="number">0x7fc2a152a880</span>&gt;</span><br><span class="line"> A  view did  disappear &lt;A_ViewController: <span class="number">0x7fc2a14ac490</span>&gt;</span><br><span class="line"></span><br><span class="line">-------------------------DISMISS----------------------------</span><br><span class="line"></span><br><span class="line"> B  view will disappear &lt;B_ViewController: <span class="number">0x7fc2a152a880</span>&gt;</span><br><span class="line"> A  view will appear    &lt;A_ViewController: <span class="number">0x7fc2a14ac490</span>&gt;</span><br><span class="line"> A  view did  appear    &lt;A_ViewController: <span class="number">0x7fc2a14ac490</span>&gt;</span><br><span class="line"> B  view did  disappear &lt;B_ViewController: <span class="number">0x7fc2a152a880</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这里其实已经和push的转场不一样了。普通模态的转场的顺序是这样的</p>
<p><code>A-willDisappear</code> –&gt; <code>B-willAppear</code> –&gt; <code>B-didAppear</code> –&gt; <code>A-didDisappear</code></p>
<p>再看看前面提到的那两种特殊的模态转场。因为在这两种方式的转场下A的view是不会消失的，所以所有与A有关的 appear 或 disappear 方法都不会被调用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-----------------------CustomPresent------------------------</span><br><span class="line"></span><br><span class="line"> B  view will appear    &lt;B_ViewController: <span class="number">0x7f960249bac0</span>&gt;</span><br><span class="line"> B  view did  appear    &lt;B_ViewController: <span class="number">0x7f960249bac0</span>&gt;</span><br><span class="line"></span><br><span class="line">-------------------------DISMISS----------------------------</span><br><span class="line"></span><br><span class="line"> B  view will disappear &lt;B_ViewController: <span class="number">0x7f960249bac0</span>&gt;</span><br><span class="line"> B  view did  disappear &lt;B_ViewController: <span class="number">0x7f960249bac0</span>&gt;</span><br></pre></td></tr></table></figure>
<p>所以在这两种style下只有<code>B-willAppear</code> –&gt; <code>B-didAppear</code></p>
<h3 id="TabBar切换"><a href="#TabBar切换" class="headerlink" title="TabBar切换"></a>TabBar切换</h3><hr>
<p>TabBar 的切换也是一个很神奇的顺序</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B  view will appear    &lt;B_ViewController: <span class="number">0x7f88cbed7160</span>&gt;</span><br><span class="line">A  view will disappear &lt;A_ViewController: <span class="number">0x7f88cbed6680</span>&gt;</span><br><span class="line">A  view did  disappear &lt;A_ViewController: <span class="number">0x7f88cbed6680</span>&gt;</span><br><span class="line">B  view did  appear    &lt;B_ViewController: <span class="number">0x7f88cbed7160</span>&gt;</span><br></pre></td></tr></table></figure>
<p>与push不同的是，TabBar下，会先调用 B 的 willAppear，再调用 A 的 willDisappear</p>
<p>所以TabBar的顺序是这样的：</p>
<p><code>B-willAppear</code> –&gt; <code>A-willDisappear</code> –&gt; <code>A-didDisappear</code> –&gt; <code>B-didAppear</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<p>在每一种转场下，appear 与 disappear 都有一些不一样的顺序，一定要分清楚，不能一概而论。</p>
<p>Push： <code>A-willDisappear</code>–&gt;<code>B-willAppear</code>–&gt;<code>A-didDisappear</code>–&gt;<code>B-didAppear</code></p>
<p>Present： <code>A-willDisappear</code>–&gt;<code>B-willAppear</code>–&gt;<code>B-didAppear</code>–&gt;<code>A-didDisappear</code></p>
<p>CustomPresent： <code>B-willAppear</code>–&gt;<code>B-didAppear</code></p>
<p>TabBar： <code>B-willAppear</code>–&gt;<code>A-willDisappear</code>–&gt;<code>A-didDisappear</code>–&gt;<code>B-didAppear</code></p>
<h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><hr>
<p>为什么要把这个过程弄的这么复杂？目前还没有想法，如果有知道的朋友，希望告知。<img src="http://7xs81e.com1.z0.glb.clouddn.com/%E4%B8%80%E8%84%B8%E6%87%B5%E9%80%BC.png" ,="" width="40"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src = &quot;http://7xrpns.com1.z0.glb.clouddn.com/heading-Appear&amp;Disappear.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近几天看了好多人的面经，时不时就看到一个问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在A页面跳转到B页面的过程中 A 的 viewDidDisappear 方法和 B 的 viewDidAppear 谁先调用？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实我以前一直理所当然的认为它们的顺序就是 &lt;code&gt;A-viewDidDisappear&lt;/code&gt;  –&amp;gt; &lt;code&gt;B-viewDidAppear&lt;/code&gt;，至于为什么会这么想，就是感觉&lt;img src=&quot;http://7xs81e.com1.z0.glb.clouddn.com/%E4%B8%80%E8%84%B8%E6%87%B5%E9%80%BC.png&quot;, width = 40&gt;&lt;/p&gt;
&lt;p&gt;今天写了个Demo去测试了一下，发现完全不是自己想象的那样，每一种转场(Push,Present，TabBar切换)都是不一样的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Hcy91425/Demo/tree/master/Appear%26Disappear-Sample&quot;&gt;Demo 地址 Appear&amp;amp;Disappear-Sample&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="UIKit 学习" scheme="http://yoursite.com/categories/UIKit-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="viewDidAppear" scheme="http://yoursite.com/tags/viewDidAppear/"/>
    
  </entry>
  
  <entry>
    <title>初次接触 RunLoop</title>
    <link href="http://yoursite.com/2016/03/24/%E5%88%9D%E6%AC%A1%E6%8E%A5%E8%A7%A6-RunLoop/"/>
    <id>http://yoursite.com/2016/03/24/初次接触-RunLoop/</id>
    <published>2016-03-24T03:24:25.000Z</published>
    <updated>2016-03-24T03:26:09.000Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><img src="http://7xrpns.com1.z0.glb.clouddn.com/heading-RunLoop.png"></div>

<p>最近看了两位大神关于RunLoop的一些资料，对RunLoop算是有了一个初步的认识，在这里整理总结一下自己对于RunLoop的理解。如果我有理解错的地方，希望大家帮我指出。我看的是 <a href="http://weibo.com/239801242" target="_blank" rel="external">@ibireme</a> 的博客和 <a href="http://weibo.com/u/1364395395" target="_blank" rel="external">@我就叫Sunny怎么了</a> 的视频，链接在下面。</p>
<blockquote>
<p><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a></p>
<p><a href="http://v.youku.com/v_show/id_XODgxODkzODI0.html" target="_blank" rel="external">iOS线下分享《RunLoop》by 孙源@sunnyxx</a></p>
</blockquote>
<a id="more"></a>
<h2 id="什么是RunLoop"><a href="#什么是RunLoop" class="headerlink" title="什么是RunLoop"></a>什么是RunLoop</h2><hr>
<p>说白了就是一个循环，能够让整个程序一直运行着不会退出，接收用户的信息。当然这个循环是一个十分复杂的循环。</p>
<h2 id="RunLoop与线程的关系"><a href="#RunLoop与线程的关系" class="headerlink" title="RunLoop与线程的关系"></a>RunLoop与线程的关系</h2><hr>
<p>每个线程有一个自己的main函数，当这个main函数执行完后这个线程也就没了。所以我们需要给这个线程创建一个 RunLoop。但是在线程创建的时候并没有 RunLoop ，只有当我们第一次去获取这个线程的 RunLoop 时，才会创建。</p>
<h2 id="RunLoop的结构"><a href="#RunLoop的结构" class="headerlink" title="RunLoop的结构"></a>RunLoop的结构</h2><hr>
<p>每个 RunLoop 中有一个集合其中存放了若干个 Mode，一个 RunLoop 只能在一种 Mode 下运行，如果需要切换那么久要退出 Loop 再重新指定一个 Mode 进入。每个 Mode 中又有若干个 item ，总共有三类，分别是 <code>Source</code>,<code>Timer</code>,<code>Observer</code>。先说简单的</p>
<h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><p>Timer 就是一个定时器，我们平时使用 NSTimer 与它紧密相关。它包含一个时间长度和一个作为回调的函数指针，当它加入到 RunLoop 后，每次到那个时间点，就会执行一次回调。</p>
<h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>Observer 就是观察者，它也包含一个回调，当 RunLoop 的状态改变时，就会执行这个回调。RunLoop 有以下几种状态:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry         = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>), </span><br><span class="line">    kCFRunLoopBeforeTimers  = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>),</span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>), </span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">5</span>), </span><br><span class="line">    kCFRunLoopAfterWaiting  = (<span class="number">1U</span>L &lt;&lt; <span class="number">6</span>), </span><br><span class="line">    kCFRunLoopExit          = (<span class="number">1U</span>L &lt;&lt; <span class="number">7</span>), </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>Source就比较难理解了。反正我自己没有弄明白，还是引用一下<a href="http://weibo.com/239801242" target="_blank" rel="external">@ibireme</a>的原话吧。</p>
<blockquote>
<p>CFRunLoopSourceRef 是事件产生的地方。Source有两个版本：Source0 和 Source1。</p>
<p>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</p>
<p>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程</p>
</blockquote>
<h3 id="CFRunLoopMode-和-CFRunLoop-的结构"><a href="#CFRunLoopMode-和-CFRunLoop-的结构" class="headerlink" title="CFRunLoopMode 和 CFRunLoop 的结构"></a>CFRunLoopMode 和 CFRunLoop 的结构</h3><p>我觉得看了下面这两个结构体后，对于 RunLoop 的理解会明朗很多。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoopMode &#123;</span><br><span class="line">    CFStringRef _name;            <span class="comment">// Mode Name</span></span><br><span class="line">    CFMutableSetRef _sources0;    <span class="comment">// Set</span></span><br><span class="line">    CFMutableSetRef _sources1;    <span class="comment">// Set</span></span><br><span class="line">    CFMutableArrayRef _observers; <span class="comment">// Array</span></span><br><span class="line">    CFMutableArrayRef _timers;    <span class="comment">// Array</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">    CFMutableSetRef _commonModes;     <span class="comment">// Set</span></span><br><span class="line">    CFMutableSetRef _commonModeItems; <span class="comment">// Set&lt;Source/Observer/Timer&gt;</span></span><br><span class="line">    CFRunLoopModeRef _currentMode;    <span class="comment">// Current Runloop Mode</span></span><br><span class="line">    CFMutableSetRef _modes;           <span class="comment">// Set</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>__CFRunLoop</code> 中有一个 <code>_modes</code> 用来存放这个 RunLoop 中的所有 Mode。还有一个 <code>_currentMode</code> 用来标记当前的 Mode。而在 <code>_CFRunLoopMode</code> 中除了 <code>_name</code> 就是那三种 item，应该很容易看出来。</p>
<p>需要一提的是在 <code>__CGRunLoop</code> 中有 <code>CFMutableSetRef _commonModes;</code> <code>CFMutableSetRef _commonModeItems;</code> 这个两个结构。我们可以把一个 Mode 标记为 <code>Common</code>。 这样每次 RunLoop 内容改变时都会把 _commonModeItems 里的 items 全部同步到标记了 Common 的 Mode 中。在后面讲 timer 的例子时我们还会再提到。</p>
<h3 id="RunLoop-的内部逻辑"><a href="#RunLoop-的内部逻辑" class="headerlink" title="RunLoop 的内部逻辑"></a>RunLoop 的内部逻辑</h3><p>还是引用一下<a href="http://weibo.com/239801242" target="_blank" rel="external">@ibireme</a>的图片，十分的直观明了。</p>
<p><img src="http://7xrpns.com1.z0.glb.clouddn.com/RunLoop_1.png" alt=""></p>
<h2 id="RunLoop-应用"><a href="#RunLoop-应用" class="headerlink" title="RunLoop 应用"></a>RunLoop 应用</h2><hr>
<h3 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h3><p>在我刚刚学 iOS 的时候，一次偶然知道了 NSTimer 这个东西后，高兴的用它模仿了一个系统的计时器。源码在一次整理的时候被我删了。。只能看看截图了：</p>
<div align="center"><img src="http://7xrpns.com1.z0.glb.clouddn.com/timer1.PNG" ,="" width="500"></div>

<p>本来挺开心的，结果一滚动下面的表格，WHAT？！计时器怎么不动了？？ <img src="http://7xs81e.com1.z0.glb.clouddn.com/%E4%B8%80%E8%84%B8%E6%87%B5%E9%80%BC.png" alt=""></p>
<p>后来也查了解决办法，不过一直没搞懂为什么。现在知道了 RunLoop 后总算是明白了。</p>
<p>在主线程中有预置两个 Mode，一个是 Default，还有一个就是 UITrackingRunLoopMode，并且这两个Mode都标记了 Common。这个 Mode 在 ScrollView 滚动时会切换，用来保证滚动的流畅。而我们注册 timer 使用的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">0.1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timerAction) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
<p>会默认把这个 timer 注册到当前 RunLoop 的 DefaultMode 中，那么滚动的时候 Mode 一切换 timer 很显然就没法工作了。解决办法也很容易，可以分为两种：</p>
<ul>
<li><p>把timer注册到<code>UITrackingRunLoopMode</code>或者<code>NSRunLoopCommonModes</code>(添加到 CommonModes 中就相当于自动添加到了<code>UITrackingRunLoopMode</code>)。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二选一</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:_timer forMode:<span class="built_in">UITrackingRunLoopMode</span>];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:_timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>把timer添加到子线程的 RunLoop 中，不管是什么Mode都不会影响到主线程</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.cyrusdev.queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">   <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">       _timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">0.1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timerAction) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">       [[<span class="built_in">NSRunLoop</span> currentRunLoop] run]; <span class="comment">// 一定要在注册timer之后让 RunLoop 跑起来</span></span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>我写了一个Demo，地址在这里，可以感受一下：</p>
<blockquote>
<p><a href="https://github.com/Hcy91425/Demo" target="_blank" rel="external">RunLoopDemo</a></p>
</blockquote>
<h3 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h3><p>在 App 启动后，系统会在主线程的 RunLoop 里注册两个 Observer。</p>
<p>第一个 Observer 监听 <code>kCFRunLoopEntry</code> 也就是即将进入 RunLoop 的状态，在这里会创建一个自动释放池。</p>
<p>第二个 Observer 监听 <code>kCFRunLoopBeforeWaiting</code> 以及 <code>kCFRunLoopExit</code> 两个状态。在 RunLoop 即将进入休眠时释放旧池，创建新池。在 RunLoop 要退出时释放池子。</p>
<h3 id="让一个子线程一直运行"><a href="#让一个子线程一直运行" class="headerlink" title="让一个子线程一直运行"></a>让一个子线程一直运行</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">	<span class="comment">// 创建子线程</span></span><br><span class="line">    <span class="keyword">self</span>.thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(threadMain) object:<span class="literal">nil</span>];</span><br><span class="line">    [<span class="keyword">self</span>.thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)threadMain &#123;</span><br><span class="line">    [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@"myThread"</span>]; </span><br><span class="line">    <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">    [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    [runLoop run];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我在 myThread 线程中创建了一个 RunLoop，这个线程就不会自动销毁了。我们可以暂停程序看一下它的线程堆栈：</p>
<div align="center"><img src="http://7xrpns.com1.z0.glb.clouddn.com/%E7%BA%BF%E7%A8%8B%E5%A0%86%E6%A0%88.png" ,="" width="500"></div>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<p>对于 RunLoop 的了解其实还很浅，只能有一个大概的结构，不过了解了这些内容对于整个App运行的过程还是会更加深入一些了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://7xrpns.com1.z0.glb.clouddn.com/heading-RunLoop.png&quot;&gt;&lt;/div&gt;

&lt;p&gt;最近看了两位大神关于RunLoop的一些资料，对RunLoop算是有了一个初步的认识，在这里整理总结一下自己对于RunLoop的理解。如果我有理解错的地方，希望大家帮我指出。我看的是 &lt;a href=&quot;http://weibo.com/239801242&quot;&gt;@ibireme&lt;/a&gt; 的博客和 &lt;a href=&quot;http://weibo.com/u/1364395395&quot;&gt;@我就叫Sunny怎么了&lt;/a&gt; 的视频，链接在下面。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.ibireme.com/2015/05/18/runloop/&quot;&gt;深入理解RunLoop&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://v.youku.com/v_show/id_XODgxODkzODI0.html&quot;&gt;iOS线下分享《RunLoop》by 孙源@sunnyxx&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="RunLoop" scheme="http://yoursite.com/tags/RunLoop/"/>
    
  </entry>
  
  <entry>
    <title>iOS 自定义转场动画 初窥</title>
    <link href="http://yoursite.com/2016/03/18/iOS-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB-%E5%88%9D%E7%AA%A5/"/>
    <id>http://yoursite.com/2016/03/18/iOS-自定义转场动画-初窥/</id>
    <published>2016-03-18T08:55:42.000Z</published>
    <updated>2016-03-24T03:29:52.000Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><img src="http://7xrpns.com1.z0.glb.clouddn.com/heading-customTransition.png"></div>

<p>这两天学习了一下自定义转场动画的内容，刚开始看的时候被这几个又长又很相似的协议弄的晕头转向，所以希望能写一篇浅显易懂的入门文章。本文的内容会比较基础，不会涉及的很深的，就像题目说的<code>初窥</code>。通过本文可以用最简单的方式实现最简单的自定义转场动画。如果你需要更加深入的知识，可以参考官方文档。</p>
<a id="more"></a>
<blockquote>
<p><a href="https://developer.apple.com/library/prerelease/ios/featuredarticles/ViewControllerPGforiPhoneOS/CustomizingtheTransitionAnimations.html" target="_blank" rel="external">Customizing the Transition Animations</a></p>
</blockquote>
<p><strong>本文中的 Demo 可以从 <a href="https://github.com/Hcy91425/Demo" target="_blank" rel="external">这里</a> 下载</strong></p>
<hr>
<p>在讲主要的内容之前我们需要分清几个概念：</p>
<ul>
<li>presentingViewController</li>
<li>presentedViewController</li>
<li>fromViewController</li>
<li>toViewController</li>
</ul>
<p><code>presentingVC</code>和<code>presentedVC</code>的概念比较容易理解，前者就是 <strong>执行present</strong> 动作的那个控制器，而后者就是 <strong>被present</strong> 的那个控制器，这两个控制器的身份是始终不会改变的。</p>
<p><code>fromVC</code>和<code>toVC</code>是个相对的概念，在执行 <strong>present</strong> 的时候<code>presentingVC</code>就是<code>fromVC</code>，而<code>presentedVC</code>就是<code>toVC</code>。在 <strong>dismiss</strong> 的时候就要反一反了<code>presentedVC</code>是<code>fromVC</code>,而<code>presentingVC</code>是<code>toVC</code>。官方有一张图是这样的：</p>
<div align="center"><img src="http://7xrpns.com1.z0.glb.clouddn.com/from&to.png" width="400"></div>

<h2 id="普通-view-controller-自定义转场"><a href="#普通-view-controller-自定义转场" class="headerlink" title="普通 view controller 自定义转场"></a>普通 view controller 自定义转场</h2><hr>
<p>我们先以普通的 view controller 为例子，讲 present 和 dismiss 的转场。往简单了说，我们只需要知道 3 个协议就可以实现自定义转场。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIViewControllerContextTransitioning</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIViewControllerAnimatedTransitioning</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIViewControllerTransitioningDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第一个协议<code>UIViewControllerContextTransitioning</code> 实现了这个协议的对象，我它为<code>转场上下文</code>，一般来说，转场上下文不用我们自己实现，由系统提供给我们。通过它，我们可以获取到很多转场相关的信息。这里我只列举几个重要的属性或方法，其他的看名字和注释也能很容易知道它们的用途：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有要执行动画的 view 都要加入到 containerView</span></span><br><span class="line">- (<span class="built_in">UIView</span> *)containerView;	</span><br><span class="line"><span class="comment">// 通过 key 来返回转场前，转场后的 view controller</span></span><br><span class="line"><span class="comment">// UITransitionContextFromViewControllerKey</span></span><br><span class="line"><span class="comment">// UITransitionContextToViewControllerKey</span></span><br><span class="line">- (<span class="built_in">UIViewController</span> *)viewControllerForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="comment">// 可以得到参与转场的 view controller 起始和结束时的 frame，一般来说通过 fromVC 的到起始的，通过 toVC 的到结束时的</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)initialFrameForViewController:(<span class="built_in">UIViewController</span> *)vc;</span><br><span class="line">- (<span class="built_in">CGRect</span>)finalFrameForViewController:(<span class="built_in">UIViewController</span> *)vc;</span><br><span class="line"><span class="comment">// 在转场动画结束，或者取消时要通知系统是否完成</span></span><br><span class="line">- (<span class="keyword">void</span>)completeTransition:(<span class="built_in">BOOL</span>)didComplete;</span><br></pre></td></tr></table></figure>
<p>第二个协议<code>UIViewControllerAnimatedTransitioning</code> 负责的是转场动画的内容，我把实现了这个协议的对象称作<code>动画控制器</code>。它有两个必须实现的方法：<code>- (NSTimeInterval)transitionDuration:</code>和<code>- (void)animateTransition:</code>。第一个方法用来返回动画的时长，而第二个方法就是实现动画的过程，它有一个参数，这个参数就是一个<code>转场上下文</code>，通过这个参数我们可以取到很多转场的信息，然后进行动画。</p>
<p>第三个协议<code>UIViewControllerTransitioningDelegate</code> 我们需设置<code>presentedVC</code>的<code>transitioningDelegate</code>属性为一个实现了这个协议的对象。我们现在只要先关注这个协议的两个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 present 动画控制器</span></span><br><span class="line">- (<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForPresentedController:(<span class="built_in">UIViewController</span> *)presented presentingController:(<span class="built_in">UIViewController</span> *)presenting sourceController:(<span class="built_in">UIViewController</span> *)source;</span><br><span class="line"><span class="comment">// 返回 dismiss 动画控制器</span></span><br><span class="line">- (<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForDismissedController:(<span class="built_in">UIViewController</span> *)dismissed;</span><br></pre></td></tr></table></figure>
<p>我们可以把 present 和 dismiss 动画控制器写成一个对象，在内部通过一些逻辑判断来执行对应的动画，当然也可以分成两个对象。</p>
<p>在知道了上面这些内容后，我们就可以一起来写一个 demo 来学习自定义转场动画了。</p>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><hr>
<p>先写两个 view controller，分别是 presentingVC 和 presentedVC，内容基本上是一样的，我就不贴两份了。只有<code>buttonClicked</code>方法不一样，一个是 present， 一个是 dismiss。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PresentingViewController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIButton</span> *button = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeSystem</span>];</span><br><span class="line">    button.bounds = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">30</span>);</span><br><span class="line">    button.center = <span class="keyword">self</span>.view.center;</span><br><span class="line">    [button setTitle:<span class="string">@"present view controller"</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    [button addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(buttonClicked) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:button];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)buttonClicked &#123;</span><br><span class="line">    PresentedViewController *presentedVC = [PresentedViewController new];</span><br><span class="line">    [<span class="keyword">self</span> presentViewController:presentedVC animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ----- in PresentedViewController.m -----</span></span><br><span class="line">- (<span class="keyword">void</span>)buttonClicked &#123;</span><br><span class="line">    [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成这些后我们的程序就能实现转场了，只不过是系统默认的转场方式。接下来，我们要写一个自己的动画控制器，为了区分和系统的动画，我们的动画选择<code>从上往下</code>划出的转场方式。我们新建一个类，让它遵循<code>UIViewControllerAnimatedTransitioning</code>协议。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AnimationController.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AnimationController</span> : <span class="title">NSObject</span>&lt;<span class="title">UIViewControllerAnimatedTransitioning</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AnimationController.m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AnimationController</span></span></span><br><span class="line"><span class="comment">// 转场的时间</span></span><br><span class="line">- (<span class="built_in">NSTimeInterval</span>)transitionDuration:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 转场动画实现</span></span><br><span class="line">- (<span class="keyword">void</span>)animateTransition:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123;</span><br><span class="line">    <span class="comment">// 通过 key 取到 fromVC 和 toVC</span></span><br><span class="line">    <span class="built_in">UIViewController</span> *fromVC = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextFromViewControllerKey</span>];</span><br><span class="line">    <span class="built_in">UIViewController</span> *toVC = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextToViewControllerKey</span>];</span><br><span class="line">    <span class="comment">// 把 toVC 加入到 containerView</span></span><br><span class="line">    <span class="built_in">UIView</span> *containerView = [transitionContext containerView];</span><br><span class="line">    [containerView addSubview:toVC.view];</span><br><span class="line">    <span class="comment">// 一些动画要用的的数据</span></span><br><span class="line">    <span class="built_in">CGRect</span> finalFrame = [transitionContext finalFrameForViewController:toVC];</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> duration = [<span class="keyword">self</span> transitionDuration:transitionContext];</span><br><span class="line">    <span class="comment">// 动画过程</span></span><br><span class="line">    <span class="keyword">if</span> (toVC.isBeingPresented) &#123;</span><br><span class="line">        toVC.view.frame = <span class="built_in">CGRectOffset</span>(finalFrame, <span class="number">0</span>, -finalFrame.size.height);</span><br><span class="line">        [<span class="built_in">UIView</span> animateWithDuration:duration</span><br><span class="line">                         animations:^&#123;</span><br><span class="line">                             toVC.view.frame = finalFrame;</span><br><span class="line">                         &#125;</span><br><span class="line">                         completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">                             <span class="comment">// 结束后要通知系统</span></span><br><span class="line">                             [transitionContext completeTransition:<span class="literal">YES</span>];</span><br><span class="line">                         &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fromVC.isBeingDismissed) &#123;</span><br><span class="line">        [containerView sendSubviewToBack:toVC.view];</span><br><span class="line">        [<span class="built_in">UIView</span> animateWithDuration:duration</span><br><span class="line">                         animations:^&#123;</span><br><span class="line">                             fromVC.view.frame = <span class="built_in">CGRectOffset</span>(finalFrame, <span class="number">0</span>, -finalFrame.size.height);</span><br><span class="line">                         &#125;</span><br><span class="line">                         completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">                             <span class="comment">// dismiss 动画添加了手势后可能出现转场取消的状态，所以要根据状态来判定是否完成转场</span></span><br><span class="line">                             <span class="built_in">BOOL</span> isComplete = ![transitionContext transitionWasCancelled];</span><br><span class="line">                             [transitionContext completeTransition:isComplete];</span><br><span class="line">                         &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>第一个方法，我们返回了动画的时间 0.8 秒</li>
<li>第二个方法<ul>
<li>先通过 key 取到 fromVC 和 toVC。</li>
<li>然后把 toVC 的 view 加入到 containerView 中 ，fromVC 的 view 是本来就在 containerView 中的</li>
<li>动画的过程分为两块，分别是 present 动画 和 dismiss 动画，我们可以通过 UIViewController 自带的 <code>isBeingPresented</code> 和  <code>isBeingDismissed</code> 属性来判断当前是那种类型的转场。动画的过程就可以自己发挥想象力了。在动画结束后要通知系统完成转场，这里要注意的是，因为稍后我们要给 dismiss 添加手势驱动，所以转场存在取消的可能，所以我们通过<code>[transitionContext transitionWasCancelled]</code>来得到转场的状态，再判断是否通知系统转场完成。</li>
</ul>
</li>
</ul>
<p>最后一步，我们要通过<code>UIViewControllerTransitioningDelegate</code>把<code>动画控制器</code>和<code>视图控制器</code>联系起来。我们要给<code>PresentingViewController</code>添加一些内容。</p>
<p>先让 <code>presentingVC</code> 遵循 <code>UIViewControllerTransitioningDelegate</code> 协议，并且添加一个属性。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PresentingViewController</span> ()&lt;<span class="title">UIViewControllerTransitioningDelegate</span>&gt;</span></span><br><span class="line"><span class="comment">// 动画控制器</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt; animationController;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>然后在<code>- (void)viewDidLoad</code>中初始化动画控制器 <code>_animationController = [AnimationController new];</code>。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">	[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 初始化动画控制器</span></span><br><span class="line">    _animationController = [AnimationController new];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着在 <code>- (void)buttonClicked</code>方法中设置<code>presentedVC</code>的代理</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)buttonClicked &#123;</span><br><span class="line">    PresentedViewController *presentedVC = [PresentedViewController new];</span><br><span class="line">    <span class="comment">// 设置 presented view controller 的转场代理</span></span><br><span class="line">    presentedVC.transitioningDelegate = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span> presentViewController:presentedVC animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后添加两个代理方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 present 动画控制器</span></span><br><span class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForPresentedController:(<span class="built_in">UIViewController</span> *)presented presentingController:(<span class="built_in">UIViewController</span> *)presenting sourceController:(<span class="built_in">UIViewController</span> *)source &#123;</span><br><span class="line">    <span class="keyword">return</span> _animationController;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 dismiss 动画控制器</span></span><br><span class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForDismissedController:(<span class="built_in">UIViewController</span> *)dismissed &#123;</span><br><span class="line">    <span class="keyword">return</span> _animationController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们已经完成了一个自定义的转场动画了😀</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>presentedVC 的 modalPresentationStyle 默认为<code>UIModalPresentationFullScreen</code>,这种情况下在转场完成后系统会自动隐藏 presentingVC 的 view 。如果我们设置了 <code>UIModalPresentationCustom</code>那么转场完成后，presentingVC 的 view 不会隐藏。一般来说在动画的时候我们都会把 toVC 的 view 加入到 containerView 中，在这种模式下执行 dismiss 的时候我们不能把 toVC.view（presentingVC.view） 加入到 containerView 中，因为这个 view 并由系统额外管理，如果我们改变了它，那就有可能把从原来的视图层次中移除而导致它消失不见。</p>
<h3 id="交互式转场"><a href="#交互式转场" class="headerlink" title="交互式转场"></a>交互式转场</h3><hr>
<p>实现交互式的转场需要在<code>UIViewControllerTransitioningDelegate</code>的协议方法中返回一个实现了<code>UIViewControllerInteractiveTransitioning</code>的对象。官方已经给我们封装好了一个<code>UIPercentDrivenInteractiveTransition</code>类，我们只要继承这个类在加入我们自己的一些内容就可以实现交互式转场。有几个方法我们需要先知道：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新转场状态</span></span><br><span class="line">- (<span class="keyword">void</span>)updateInteractiveTransition:(<span class="built_in">CGFloat</span>)percentComplete;</span><br><span class="line"><span class="comment">// 取消转场</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelInteractiveTransition;</span><br><span class="line"><span class="comment">// 完成转场</span></span><br><span class="line">- (<span class="keyword">void</span>)finishInteractiveTransition;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，在转场发生时，如果返回了<code>交互控制器</code>，但是却没有通过交互的方式来执行转场，那么整个过程就卡住。所以我们需要给交互控制器添加一个属性，用来监听当前是否是通过手势驱动，如果不是我们就返回一个 nil，这样就不会执行交互式转场，而只会执行普通的动画转场。接下来我们来看一下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InteractionController.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">InteractionController</span> : <span class="title">UIPercentDrivenInteractiveTransition</span></span></span><br><span class="line"><span class="comment">// 标记是否是交互转场</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, getter=isInteracting)<span class="built_in">BOOL</span> interacting;</span><br><span class="line"><span class="comment">// 一些初始化工作</span></span><br><span class="line">- (<span class="keyword">void</span>)prepareForViewController:(<span class="built_in">UIViewController</span> *)viewController;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// InteractionController.m</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">InteractionController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>)<span class="built_in">UIViewController</span> *presentedVC;	<span class="comment">// 注意是弱引用</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>)<span class="built_in">BOOL</span> shouldComplete;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">InteractionController</span></span></span><br><span class="line"><span class="comment">// 给 viewController 的 view 添加手势</span></span><br><span class="line">- (<span class="keyword">void</span>)prepareForViewController:(<span class="built_in">UIViewController</span> *)viewController &#123;</span><br><span class="line">    _presentedVC = viewController;</span><br><span class="line">    <span class="built_in">UIPanGestureRecognizer</span> *panGesture = [[<span class="built_in">UIPanGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(panGestureAction:)];</span><br><span class="line">    [viewController.view addGestureRecognizer:panGesture];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)panGestureAction:(<span class="built_in">UIPanGestureRecognizer</span> *)gestureRecognizer &#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> translation = [gestureRecognizer translationInView:gestureRecognizer.view.superview];</span><br><span class="line">    <span class="comment">// 动画的百分比</span></span><br><span class="line">    <span class="built_in">CGFloat</span> percent = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (gestureRecognizer.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateBegan</span>:</span><br><span class="line">            <span class="comment">// 设置交互状态为 YES</span></span><br><span class="line">            _interacting = <span class="literal">YES</span>;</span><br><span class="line">            <span class="comment">// 手势开始时要调用 dismiss</span></span><br><span class="line">            [_presentedVC dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateChanged</span>:</span><br><span class="line">            <span class="comment">// 计算百分比</span></span><br><span class="line">            percent = -translation.y/_presentedVC.view.bounds.size.height;</span><br><span class="line">            <span class="comment">// 更新转场的进度 传入的参数值要在 0.0~1.0 之间</span></span><br><span class="line">            [<span class="keyword">self</span> updateInteractiveTransition:percent];</span><br><span class="line">            <span class="comment">// 如果滑动超过 30% 就视为转场完成</span></span><br><span class="line">            _shouldComplete = (percent &gt; <span class="number">0.3</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateCancelled</span>:</span><br><span class="line">            _interacting = <span class="literal">NO</span>;</span><br><span class="line">            [<span class="keyword">self</span> cancelInteractiveTransition];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateEnded</span>:</span><br><span class="line">            _interacting = <span class="literal">NO</span>;</span><br><span class="line">            <span class="keyword">if</span> (_shouldComplete) &#123;</span><br><span class="line">                [<span class="keyword">self</span> finishInteractiveTransition];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                [<span class="keyword">self</span> cancelInteractiveTransition];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>注释已经写得很详细了，需要注意的是在完成或者取消的时候一定要调用对应的方法来通知系统。完成了这个类后我们需要再次修改 <code>PresentingViewController</code>的内容。    </p>
<p>再添加一个属性</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)InteractionController *interactiveTransition;</span><br></pre></td></tr></table></figure>
<p>并且在<code>- (void)viewDidLoad</code>中初始化它</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 初始化交互控制器</span></span><br><span class="line">    _interactiveTransition = [InteractionController new];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>- (void)buttonClicked</code>中执行<code>- (void)prepareForViewController:(UIViewController *)viewController</code>方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)buttonClicked &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 添加交互</span></span><br><span class="line">    [_interactiveTransition prepareForViewController:presentedVC];</span><br><span class="line">    [<span class="keyword">self</span> presentViewController:presentedVC animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在最后添加协议方法,在方法中要通过 <code>isInteracting</code> 属性来判断是否是执行交互式转场，如果不是则返回 <code>nil</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 dismiss 的交互控制器</span></span><br><span class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerInteractiveTransitioning</span>&gt;)interactionControllerForDismissal:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animator &#123;</span><br><span class="line">    <span class="keyword">return</span> _interactiveTransition.isInteracting ? _interactiveTransition : <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于普通的 view controller 的自定义转场就到此结束了。如果你按照文章的步骤一步一步写下来，相信你已经完成了一个最简单的自定义转场。</p>
<h2 id="容器-view-controller-的自定义转场"><a href="#容器-view-controller-的自定义转场" class="headerlink" title="容器 view controller 的自定义转场"></a>容器 view controller 的自定义转场</h2><hr>
<p><code>UINavigationController</code>，<code>UITabBarController</code> 都属于 容器VC。与普通的 VC 不同的是，它们通过 <code>UINavigationControllerDelegate</code>或者<code>UITabBarControllerDelegate</code>的代理方法来返回<code>动画控制器</code>，而动画控制器的具体实现，几乎是一模一样的。我放在 <a href="https://github.com/Hcy91425/Demo" target="_blank" rel="external">github 上的 Demo</a> 中，有这三种自定转场的代码，用的基本上是同一个 animationController ，如果你掌握了前面的内容，那么这里也就不是问题了。具体的代码我就不展开了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://7xrpns.com1.z0.glb.clouddn.com/heading-customTransition.png&quot;&gt;&lt;/div&gt;

&lt;p&gt;这两天学习了一下自定义转场动画的内容，刚开始看的时候被这几个又长又很相似的协议弄的晕头转向，所以希望能写一篇浅显易懂的入门文章。本文的内容会比较基础，不会涉及的很深的，就像题目说的&lt;code&gt;初窥&lt;/code&gt;。通过本文可以用最简单的方式实现最简单的自定义转场动画。如果你需要更加深入的知识，可以参考官方文档。&lt;/p&gt;
    
    </summary>
    
      <category term="UIKit 学习" scheme="http://yoursite.com/categories/UIKit-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="自定义转场" scheme="http://yoursite.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C 块（Block）的使用与理解</title>
    <link href="http://yoursite.com/2016/03/13/Objective-C-%E5%9D%97%EF%BC%88Block%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2016/03/13/Objective-C-块（Block）的使用与理解/</id>
    <published>2016-03-13T08:33:30.000Z</published>
    <updated>2016-03-30T02:24:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><div align="center"><img src="http://7xrad5.com1.z0.glb.clouddn.com/heading_block.png"></div></p>
<hr>
<p>块（Block）是在 iOS 开发中很常用的一个工具，它可以使我们代码的业务逻辑更加的紧凑。本文会分两部分来讲块，第一部分是块的基础知识，第二部分是对块的本质的一些理解。</p>
<a id="more"></a>
<h2 id="块的基础知识"><a href="#块的基础知识" class="headerlink" title="块的基础知识"></a>块的基础知识</h2><hr>
<h3 id="块的声明"><a href="#块的声明" class="headerlink" title="块的声明"></a>块的声明</h3><p>块的声明类似于函数指针，只不过把 * 换成了 ^ 。声明时最前面是返回类型，中间是块名，最后是参数类型。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// returnType (^blockName) (parameters)</span></span><br><span class="line"><span class="keyword">int</span> (^someBlock) (<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<h3 id="块的实现"><a href="#块的实现" class="headerlink" title="块的实现"></a>块的实现</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ^returnType(parameters)&#123;/*code*/&#125;;</span></span><br><span class="line">^<span class="keyword">int</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中返回值是可以省略的,它可以自动判断，如果参数也是空的话我们可以简化成这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="块的使用"><a href="#块的使用" class="headerlink" title="块的使用"></a>块的使用</h3><p>块的使用就像使用 C 函数一样</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someBlock（<span class="number">1</span>，<span class="number">2</span>）;</span><br></pre></td></tr></table></figure>
<h3 id="用-typedef-来简化块的声明"><a href="#用-typedef-来简化块的声明" class="headerlink" title="用 typedef 来简化块的声明"></a>用 typedef 来简化块的声明</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> (^CYAddBlock) (<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">CYAddBlock addBlock = ^(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;;</span><br><span class="line">addBlock(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h3 id="块能捕获在它声明范围里的所有变量"><a href="#块能捕获在它声明范围里的所有变量" class="headerlink" title="块能捕获在它声明范围里的所有变量"></a>块能捕获在它声明范围里的所有变量</h3><p>但是不能再块中修改捕获到的变量，如果我们尝试修改编译器会报错，无法通过编译。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> (^someBlock) () = ^&#123;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> result = someBlock();	<span class="comment">// result = 0</span></span><br></pre></td></tr></table></figure>
<h3 id="用-block-修饰变量，可以在块中修改变量的值"><a href="#用-block-修饰变量，可以在块中修改变量的值" class="headerlink" title="用 __block 修饰变量，可以在块中修改变量的值"></a>用 __block 修饰变量，可以在块中修改变量的值</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> (^someBlock) () = ^&#123;</span><br><span class="line">	<span class="keyword">return</span> ++count;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> result = someBlock();	<span class="comment">// result = 1</span></span><br></pre></td></tr></table></figure>
<p>其实块在捕获变量时只是拷贝了一份变量的值，而用 __block 修饰后，拷贝的是变量的地址，所以我们就可以在块中修改变量了。这就和 C 语言中函数的参数是类似的道理。</p>
<h3 id="小心产生循环引用"><a href="#小心产生循环引用" class="headerlink" title="小心产生循环引用"></a>小心产生循环引用</h3><p>在一个类中，块能直接访问并修改实例变量的值，但是一定要注意不管是通过 self 来访问属性还是直接通过 _instanceVariable 来访问<strong>都会捕获 self</strong>。因为在直接访问 _instanceVariable 等效于这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>-&gt;_instanceVariable;</span><br></pre></td></tr></table></figure>
<p>而一旦捕获了self， 我们就一定要注意<strong>循环引用</strong>导致的内存泄露了。我们在 CYClass 中声明了一个块和一个属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^CYBlock) ();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CYClass</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)<span class="built_in">NSString</span> *aString;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)CYBlock aBlock;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>然后重写它的 init 和 dealloc 方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CYClass</span></span></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _aString = <span class="string">@"Hello Cyrus"</span>;</span><br><span class="line">        _aBlock = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, _aString);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"CYClass deinit"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>然后我们实例化一个对象，紧接着就把它设为 nil 会发现 dealloc 方法并没有被调用，也就是说发生了内存泄露。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CYClass *c = [CYClass new];</span><br><span class="line">c = <span class="literal">nil</span>;</span><br></pre></td></tr></table></figure>
<p>就像这样：</p>
<p><img src="http://7xrpns.com1.z0.glb.clouddn.com/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png" alt=""></p>
<p>我们可以通过 __weak 来打破这个循环，我们修改一下初始化方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _aString = <span class="string">@"Hello Cyrus"</span>;</span><br><span class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        _aBlock = ^&#123;</span><br><span class="line">        	__<span class="keyword">strong</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) strongSelf = weakSelf;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, strongSelf.aString);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行之前的代码就会发现这个对象成功的销毁了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-12</span> <span class="number">16</span>:<span class="number">30</span>:<span class="number">24.995</span> BlockExample[<span class="number">4777</span>:<span class="number">111670</span>] CYClass deinit</span><br></pre></td></tr></table></figure>
<h2 id="块的本质"><a href="#块的本质" class="headerlink" title="块的本质"></a>块的本质</h2><hr>
<h3 id="块的结构"><a href="#块的结构" class="headerlink" title="块的结构"></a>块的结构</h3><p>我们可以在<a href="https://llvm.org/svn/llvm-project/compiler-rt/tags/Apple/Libcompiler_rt-10/BlocksRuntime/Block_private.h" target="_blank" rel="external">这里</a>找到 Block 的定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Block_descriptor &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);</span><br><span class="line">    <span class="keyword">void</span> (*dispose)(<span class="keyword">void</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Block_layout &#123;</span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> reserved; </span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</span><br><span class="line">    <span class="keyword">struct</span> Block_descriptor *descriptor;</span><br><span class="line">    <span class="comment">/* Imported variables. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看到 Block_layout 结构体里的第一个变量是一个 <strong>isa 指针</strong>， 我们应该就能猜到 <strong>Block 也是一个对象</strong>。然后再看第四个变量是一个叫 <strong>invoke 的函数指针</strong>，它指向的就是 <strong>Block 具体实现的函数</strong>了,这个函数至少要接受一个 void*  类型的参数，这个参数就是块本身。再下面的 descriptor 指向的就是 Block_descriptor 结构体，里面就是一些 Block 的信息。而在这些变量下面存放的就是 <strong>Block 捕获的那些变量</strong>。</p>
<h3 id="块的类型"><a href="#块的类型" class="headerlink" title="块的类型"></a>块的类型</h3><p>在 OC 中一共有3种块，分别是：</p>
<ul>
<li>全局块，不会访问任何外部变量</li>
<li>栈块，保存在栈中, 当函数退出后就会被销毁，通过copy可以复制到堆上</li>
<li>堆块，保存在堆中</li>
</ul>
<p>我们在 MRC 的环境下运行下面的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^globalBlock)()  = ^&#123; <span class="built_in">NSLog</span>(<span class="string">@"global block"</span>); &#125;;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, globalBlock);</span><br><span class="line">        </span><br><span class="line"><span class="built_in">NSString</span> *str1 = <span class="string">@"stack block"</span>;</span><br><span class="line"><span class="keyword">void</span> (^stackBlcok)() = ^&#123; <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str1); &#125;;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, stackBlcok);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSString</span> *str2 = <span class="string">@"malloc block"</span>;</span><br><span class="line"><span class="keyword">void</span> (^mallockBlock)() = [^&#123; <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str2); &#125; <span class="keyword">copy</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, mallockBlock);</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-13</span> <span class="number">16</span>:<span class="number">23</span>:<span class="number">50.676</span> BlockExample[<span class="number">1760</span>:<span class="number">28902</span>] &lt;__<span class="built_in">NSGlobalBlock__</span>: <span class="number">0x1000042b0</span>&gt;</span><br><span class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-13</span> <span class="number">16</span>:<span class="number">23</span>:<span class="number">50.677</span> BlockExample[<span class="number">1760</span>:<span class="number">28902</span>] &lt;__<span class="built_in">NSStackBlock__</span>: <span class="number">0x7fff5fbff790</span>&gt;</span><br><span class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-13</span> <span class="number">16</span>:<span class="number">23</span>:<span class="number">50.677</span> BlockExample[<span class="number">1760</span>:<span class="number">28902</span>] &lt;__<span class="built_in">NSMallocBlock__</span>: <span class="number">0x100303fa0</span>&gt;</span><br></pre></td></tr></table></figure>
<p>结果和我们预期的结果是一样的。我们在换成 ARC 的环境下运行一次：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-13</span> <span class="number">16</span>:<span class="number">26</span>:<span class="number">05.767</span> BlockExample[<span class="number">1805</span>:<span class="number">29822</span>] &lt;__<span class="built_in">NSGlobalBlock__</span>: <span class="number">0x1000052f0</span>&gt;</span><br><span class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-13</span> <span class="number">16</span>:<span class="number">26</span>:<span class="number">05.768</span> BlockExample[<span class="number">1805</span>:<span class="number">29822</span>] &lt;__<span class="built_in">NSMallocBlock__</span>: <span class="number">0x100400340</span>&gt;</span><br><span class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-13</span> <span class="number">16</span>:<span class="number">26</span>:<span class="number">05.769</span> BlockExample[<span class="number">1805</span>:<span class="number">29822</span>] &lt;__<span class="built_in">NSMallocBlock__</span>: <span class="number">0x1004001b0</span>&gt;</span><br></pre></td></tr></table></figure>
<p>我们发现原来的栈块也变成了堆块。这是因为在把一个快赋值给一个strong对象时 ARC 会自动帮我们执行一次copy。如果我们直接这样，那么还是会打印出 __NSStackBlock :</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str1 = <span class="string">@"stack block"</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, ^&#123; <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str1); &#125;);</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-13</span> <span class="number">16</span>:<span class="number">30</span>:<span class="number">06.180</span> BlockExample[<span class="number">1881</span>:<span class="number">32260</span>] &lt;__<span class="built_in">NSStackBlock__</span>: <span class="number">0x7fff5fbff798</span>&gt;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://7xrad5.com1.z0.glb.clouddn.com/heading_block.png&quot;&gt;&lt;/div&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;块（Block）是在 iOS 开发中很常用的一个工具，它可以使我们代码的业务逻辑更加的紧凑。本文会分两部分来讲块，第一部分是块的基础知识，第二部分是对块的本质的一些理解。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C 学习" scheme="http://yoursite.com/categories/Objective-C-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Block" scheme="http://yoursite.com/tags/Block/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C runtime 的简单理解与使用（一）</title>
    <link href="http://yoursite.com/2016/03/10/Objective-C-runtime-%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2016/03/10/Objective-C-runtime-的简单理解与使用（一）/</id>
    <published>2016-03-10T11:49:34.000Z</published>
    <updated>2016-11-13T08:17:41.000Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><img src="http://7xrad5.com1.z0.glb.clouddn.com/heading_runtime1.png"></div>

<hr>
<p>一开始接触 iOS 的时候，学的是 Swift。还有一个学期就大四，为了实习，也为了更好的理解 iOS，最近一个多月开始正式学习 Objective-C。而 runtime “运行时” 应该算是 Objective-C 的核心所在。我觉得有必要好好来理解一下 runtime。学的还不是很精，主要是通过看别人的博客和《Effective Objective-C 2.0》这本书来学习 runtime ，官方文档还没有看过，希望以后能够补上。如果有什么理解的不对的地方，希望大家指出。😆</p>
<a id="more"></a>                
<h2 id="Objective-C中的消息分发"><a href="#Objective-C中的消息分发" class="headerlink" title="Objective-C中的消息分发"></a>Objective-C中的消息分发</h2><hr>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[someObject doSomething];</span><br></pre></td></tr></table></figure>
<p>这是我们在 Objective-C 中调用方法的方式， 但其实这应该称作<strong>“传递消息”（pass a message）</strong>，给 someObject 对象传递一个 doSomething的消息。因为这行代码在编译时会变成这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(someObject, <span class="keyword">@selector</span>(doSomething))</span><br></pre></td></tr></table></figure>
<p>这是个 C 函数， 声明在 objc/message.h 头文件中，它接受两个及以上的可变参数, 第一个参数代表的是消息的接收者，第二个参数代表选择子（<a href="#selector">selector，在后面我们会细说</a>），如果要调用的方法还有别的参数，就会跟在这两个参数后面。还有其他几个类似的函数，来处理不同的情况：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSend(<span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ...)	<span class="comment">// 直接发送消息</span></span><br><span class="line"><span class="keyword">id</span> objc_msgSendSuper(<span class="keyword">struct</span> objc_super *<span class="keyword">super</span>, SEL op, ...)	<span class="comment">// 给父类发送消息</span></span><br><span class="line"><span class="keyword">void</span> objc_msgSend_stret(<span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ...)	<span class="comment">// 返回值是结构体时，可以交给这个函数处理</span></span><br><span class="line"><span class="keyword">double</span> objc_msgSend_fpret(<span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ...)	<span class="comment">// 返回值是浮点数时，可以交给这个函数处理</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>当我们向一个对象发送一个消息时，它会在这个对象的类中根据 selector 找到真正的实现函数，如果找不到就再到它的父类中找，一层一层的找上去，最后到 NSObject 类中， 如果还没有找到，那么就会启用“消息转发机制”。这个我们以后再提。</p>
<h4 id="消息分发图示"><a href="#消息分发图示" class="headerlink" title="消息分发图示"></a>消息分发图示</h4><p><img src="http://7xrpns.com1.z0.glb.clouddn.com/messaging1.gif"></p>
<h2 id="Objective-C中类的本质"><a href="#Objective-C中类的本质" class="headerlink" title="Objective-C中类的本质"></a>Objective-C中类的本质</h2><hr>
<p>Objective-C 中的类其实是 C 中的结构体，它的基本定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa ;</span><br><span class="line">    Class super_class ;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name ;</span><br><span class="line">    <span class="keyword">long</span> version ;</span><br><span class="line">    <span class="keyword">long</span> info ;</span><br><span class="line">    <span class="keyword">long</span> instance_size ;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars ;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists ;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache ;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols ;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="comment">/* Use `Class` instead of `struct objc_class *` */</span></span><br></pre></td></tr></table></figure>
<p>我们来看一下其中比较重要的几个变量</p>
<h3 id="Class-isa"><a href="#Class-isa" class="headerlink" title="Class isa"></a>Class isa</h3><blockquote>
<p>isa 指针，表示这个对象是一个什么类。而 <strong>Class</strong> 类型， 也就是 <strong>struct objc_class *</strong> ，这是苹果在下面的注释中写到的。这说明类本身也是一个对象。在类对象中的 isa 指向的类叫做<strong>“元类”</strong>，类方法就定义在元类中。<br>总的来说就是，一个类可以有很多的实例，这些实例有着唯一的一个类对象，而这个类对象也有着唯一的一个元类。</p>
</blockquote>
<h4 id="实例，类，父类，元类之间的关系"><a href="#实例，类，父类，元类之间的关系" class="headerlink" title="实例，类，父类，元类之间的关系"></a>实例，类，父类，元类之间的关系</h4><p><img src="http://7xrpns.com1.z0.glb.clouddn.com/%E7%B1%BB%E5%92%8C%E5%85%83%E7%B1%BB.png"></p>
<h3 id="Class-super-class"><a href="#Class-super-class" class="headerlink" title="Class super_class"></a>Class super_class</h3><blockquote>
<p>super_class 指向的就是它的父类。</p>
</blockquote>
<h3 id="struct-objc-ivar-list-ivars"><a href="#struct-objc-ivar-list-ivars" class="headerlink" title="struct objc_ivar_list *ivars"></a>struct objc_ivar_list *ivars</h3><blockquote>
<p>ivars 指向的是成员变量的列表。</p>
</blockquote>
<p><span id="selector"></span></p>
<h3 id="struct-objc-method-list-methodLists"><a href="#struct-objc-method-list-methodLists" class="headerlink" title="struct objc_method_list **methodLists"></a>struct objc_method_list **methodLists</h3><blockquote>
<p>methodLists 指向的就是方法的列表。在 method_list 中存着 objc_method 类型的数组。而 objc_method 的定义如下：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">    SEL method_name ;</span><br><span class="line">    <span class="keyword">char</span> *method_types ;</span><br><span class="line">    IMP method_imp ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">id</span> (*IMP)(<span class="keyword">id</span>, SEL, ...); 	<span class="comment">// IMP 就是一个函数指针</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>看到这个结构体， 我们应该就很明确 selector 的意义了。<strong>selector</strong> 其实就是<strong>方法的一个标示</strong>，而 <strong>method_imp</strong> 指向的才是<strong>真正的函数实现</strong>。当我们向对象发送消息后， runtime根据 selector 这个标示，在method_list中找到对应的 objc_method，取到真正的函数的地址，再执行。</p>
</blockquote>
<h3 id="struct-objc-cache-cache"><a href="#struct-objc-cache-cache" class="headerlink" title="struct objc_cache *cache"></a>struct objc_cache *cache</h3><blockquote>
<p>cache 用来缓存最近调用过的的方法。 如果每次向对象发送消息都要遍历一遍方法列表那会很浪费时间， 所以会把最近调用过的方法放在缓存中。每一次发送消息时，会先查询缓存，缓存中找不到再去方法列表中找。</p>
</blockquote>
<h3 id="struct-objc-protocol-list-protocols"><a href="#struct-objc-protocol-list-protocols" class="headerlink" title="struct objc_protocol_list *protocols"></a>struct objc_protocol_list *protocols</h3><blockquote>
<p>protocols 指向协议列表。</p>
</blockquote>
<h2 id="Runtime能做什么"><a href="#Runtime能做什么" class="headerlink" title="Runtime能做什么"></a>Runtime能做什么</h2><hr>
<ul>
<li>动态的改变成员变量的值</li>
<li>在运行时添加方法</li>
<li>交换方法的实现</li>
<li>给一个对象关联其他对象</li>
<li>消息转发</li>
<li><p>等等，许许多多我们想不到的功能</p>
<p>runtime的使用在下一篇博客中再详细讲 ~</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://7xrad5.com1.z0.glb.clouddn.com/heading_runtime1.png&quot; /&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;一开始接触 iOS 的时候，学的是 Swift。还有一个学期就大四，为了实习，也为了更好的理解 iOS，最近一个多月开始正式学习 Objective-C。而 runtime “运行时” 应该算是 Objective-C 的核心所在。我觉得有必要好好来理解一下 runtime。学的还不是很精，主要是通过看别人的博客和《Effective Objective-C 2.0》这本书来学习 runtime ，官方文档还没有看过，希望以后能够补上。如果有什么理解的不对的地方，希望大家指出。😆&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C 学习" scheme="http://yoursite.com/categories/Objective-C-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="runtime" scheme="http://yoursite.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客</title>
    <link href="http://yoursite.com/2016/03/10/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2016/03/10/第一篇博客/</id>
    <published>2016-03-10T03:04:16.000Z</published>
    <updated>2016-03-18T01:47:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>花了一个晚上加上一个上午的时间，终于把自己的博客搭起来了。以后要好好学习， 认真的写博客了。</p>
<p>嗯， 第一篇博客就是这么简短，拜拜~ 😆</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;花了一个晚上加上一个上午的时间，终于把自己的博客搭起来了。以后要好好学习， 认真的写博客了。&lt;/p&gt;
&lt;p&gt;嗯， 第一篇博客就是这么简短，拜拜~ 😆&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
</feed>
